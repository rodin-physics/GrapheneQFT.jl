var documenterSearchIndex = {"docs":
[{"location":"formalism.html#Formalism","page":"Formalism","title":"Formalism","text":"","category":"section"},{"location":"formalism.html#Hamiltonian","page":"Formalism","title":"Hamiltonian","text":"","category":"section"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"To model graphene coupled to external electronic states and influenced by an external perturbation, it is helpful to start with the following generic Hamiltonian","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"hatmathcalH = sum_ab c^dagger_a  H_ab c_b + sum_ab g^dagger_a h_ab g_b+ sum_ab g^dagger_a V_ab c_b + c^dagger_b V_ab^* g_a\n\t","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"Here, we have introduced two fermionic systems with the corresponding second-quatized operators c and g, governed by the Hamiltonians H and h, respectively, while V_ab represent the coupling between them. The subscripts a and b label the individual states in these systems.","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"The expression can be made more compact by defining mathbfc and mathbfd as column vectors of c_a and d_a:","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"hatmathcalH = \tmathbfc^dagger Hmathbfc\n\t+ \tmathbfg^dagger hmathbfg\n\t+ mathbfg^dagger V mathbfc +  mathbfc^dagger V^dagger mathbfg\n\t","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"At this point, we identify h as the Hamiltonian describing the external electronic states and H = H_0 + Delta as a combination of the pristine graphene Hamiltonian H_0 and a perturbation Delta.","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"Pristine graphene Hamiltonian can be written using the tight-binding formalism in momentum space as","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"hatH_0 = sum_mathbfq beginpmatrixa_mathbfq^dagger  b_mathbfq^dagger endpmatrix beginpmatrix 0  -t f_mathbfq  -t f^*_mathbfq  0endpmatrix beginpmatrixa_mathbfq b_mathbfqendpmatrix = sum_mathbfqc^dagger_mathbfqH_mathbfq c_mathbfq","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"where a_mathbfq and b_mathbfq are the annihilation operators for the p_z orbitals of the two sublattices, t = 28eV is the nearest-neighbor hopping integral, f_mathbfq = 1 + e^imathbfqcdotmathbfd_1+e^imathbfqcdotmathbfd_2, and mathbfd_12=dleft(pm1 sqrt3right)2 are the lattice vectors. On the other hand, coupling to the external states and the perturbation Delta are easier to write in real space. Hence, using c^dagger_mathbfq = N^-12sum_mathbfRc_mathbfR^dagger e^imathbfRcdotmathbfq = mathbfc^dagger Theta_mathbfq^dagger, where N is the number of unit cells in the system and Theta_mathbfq^dagger is a column vector of e^imathbfRcdotmathbfq, we have","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"hatH_0 =mathbfc^dagger left(   sum_mathbfq  Theta_mathbfq^dagger H_mathbfq Theta_mathbfq right)mathbfc =mathbfc^dagger Theta^dagger H_0^mathbfQ Theta mathbfc = mathbfc^dagger H_0 mathbfc","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"Here, mathbfc is a column vector of c_mathbfR, Theta is a column vector of Theta_mathbfq, and H_0^mathbfQ is a block-diagonal matrix of H_mathbfq.","category":"page"},{"location":"formalism.html#Partition-Function","page":"Formalism","title":"Partition Function","text":"","category":"section"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"Because hatmathcalH is normal-ordered, we can translate it into the imaginary-time action","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"S = sum_omega_n\tbarpsi_n leftleft(-iomega_n  - muright)mathbf1+ Hrightpsi_n\n\t+ barphi_nleftleft(-iomega_n  - muright)mathbf1+ h rightphi_n\n\t+ barphi_nV psi_n +  barpsi_n V^dagger phi_n\n\t\n\t= sum_omega_n\tbarpsi_n left(-G^-1_iomega_n+muright)psi_n\n\t\t+ barphi_nleft(-Gamma^-1_0iomega_n+mu right)phi_n\n\t\t+ barphi_nV psi_n +  barpsi_n V^dagger phi_n\n\t\t\n\t= sum_omega_n\n\tbeginpmatrix\n\t\tbarpsi_n  barphi_n\n\tendpmatrix\t \n\tbeginpmatrix\n\t\t-G^-1_iomega_n+mu\t V^dagger\n\t\t\t\n\t\t\tV -Gamma^-1_0iomega_n+mu\n\tendpmatrix\n\tbeginpmatrix\n\t\tpsi_n  phi_n\n\tendpmatrix\n\t","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"where omega_n are the fermionic Matsubara frequencies, mu is the chemical potential, and psi_n and phi_n are vectors of the Grassmann fields corresponding to c and d operators, respectively.","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"Exponentiating -S and integrating over all the Grassmann fields yields the partition function","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"mathcalZ = prod_omega_n det leftbetabeginpmatrix\n\t-G^-1_iomega_n+mu\t V^dagger\n\t\t\n\t\tV -Gamma^-1_0iomega_n+mu\nendpmatrixright","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"where beta is 1  (k_B T).","category":"page"},{"location":"formalism.html#Green's-Functions","page":"Formalism","title":"Green's Functions","text":"","category":"section"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"The partition function can be also written as","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"mathcalZ =\n\tprod_omega_n \n\tleft-beta Gamma^-1_0iomega_n+muright\n\tleft-betaleft( G_iomega_n+mu ^-1 -  VGamma_0iomega_n+muV^daggerright)right\n\t\t\n\t\t=\n    prod_omega_n \n    left-beta G^-1_iomega_n+muright\n    left-betaleft(Gamma^-1_0iomega_n+mu - V^dagger G_iomega_n+muVright)right","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"We identify the quantity in the parentheses of the first line as the inverse of the  full graphene Green's function (including the effects of the external states and a perturbation). The quantity in the parentheses of the second line is the inverse of the full Green's function of the external states.","category":"page"},{"location":"formalism.html#Graphene-Green's-Function","page":"Formalism","title":"Graphene Green's Function","text":"","category":"section"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"Defining the pristine graphene Green's function in real space as G_0z = left(z -  H_0 right)^-1 allows us write the full real-space Green's function as mathcalG_z^-1 =  G_0z^-1 - Delta -  VGamma_0zV^dagger. Inverting this expression yields","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"mathcalG_z =  leftG_0z^-1 - Delta -  VGamma_0zV^daggerright^-1\n=  left1 - G_0zleft(Delta +  VGamma_0zV^daggerright)right^-1G_0z\n\n=  G_0z+G_0zleft(Delta +  VGamma_0zV^daggerright)left 1-\nG_0zleft(Delta +  VGamma_0zV^daggerright)right^-1G_0z\n\n=  G_0z+G_0zleft left(Delta +  VGamma_0zV^daggerright)^-1-\nG_0zright^-1G_0z","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"We can obtain G_0z from the momentum-space graphene Hamiltonian as follows:","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"G_0z = left(z -  H_0 right)^-1 = left(z - Theta^dagger H_0^mathbfQTheta right)^-1 = Thetaleft(z -  H_0^mathbfQ right)^-1Theta^dagger","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"The 2times 2 elements of G_0z are computed from","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"G_0z2times 2^jk = sum_lmTheta_jlleftleft(z -  H_0^mathbfQ right)^-1right_lmTheta^dagger_mk\n\nrightarrow sum_mathbfqTheta_mathbfR_jmathbfqleftleft(z -  H_0^mathbfQ right)^-1right_mathbfqTheta^dagger_mathbfqmathbfR_k = frac1Nsum_mathbfq leftleft(z -  H_0^mathbfQ right)^-1right_mathbfq e^ileft(mathbfR_k - mathbfR_jright)cdotmathbfq\n\n= frac1Nsum_mathbfq\nbeginpmatrix\nz - tf_mathbfq\n\n- tf_mathbfq^*  z\nendpmatrixfrac1z^2 - t^2 leftf_mathbfqright e^imathbfR_kjcdotmathbfq= G_0zleft(mathbfR_kjright)","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"To compute G_0z(mathbfR), we first introduce","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"Omega^uv_z =\n\tfrac1Nsum_mathbfqinmathrmBZ\n\tfrac\n\t\te^imathbfqcdot left(umathbfd_1 + vmathbfd_2right)\n\t\n\tz^2 - t^2left f_mathbfqright^2","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"with umathbfd_1 + vmathbfd_2 = fracd2left(u - v sqrt3left(u+vright)right) and t = 28eV as the nearest-neighbor hopping energy. Using mathbfqcdot left(umathbfd_1 + vmathbfd_2right)  = fracd2leftleft(u - vright)q_x + sqrt3left(u+vright)q_yright and turning the momentum sum into an integral yields","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"Omega^uvleft(zright)\n\t= frac1left(2piright)^2oint dx oint dy\n\tfrac\n\te^i leftleft(u - vright)x + left(u+vright)yright\n\tz^2 - t^2left(1 + 4cos^2 x + 4 cos xcos y right)","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"From","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"oint dtheta frace^ilthetaW-costheta = 2pi fracleft(W - sqrtW - 1sqrtW + 1right)^lsqrtW - 1sqrtW + 1","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"we get","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"Omega^uv_z = frac12pifrac14t^2\n\toint dx frace^ileft(u - vright)xcos xfracleft(W - sqrtW - 1sqrtW + 1right)^u+vsqrtW - 1sqrtW + 1\n\t\n\tW = fracfracz^2t^2-14cos x-cos x","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"Finally, G_0z(mathbfR) for mathbfR = umathbfd_1 + vmathbfd_2 can be written as","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"G_0z(mathbfR)\n\t=\n\tbeginpmatrix\n\t\tzOmega^uv_z\n\t\t\n\t\t- tleftOmega^uv_z + Omega^uv_+z right\n\t\t\n\t\t- tleftOmega^uv_z + Omega^uv_-zright\n\t\t\n\t\tzOmega^uv_z\n\tendpmatrix\n\t\n\tOmega^uv_pmz\n\t=\n\t frac12pifrac14t^2\n\toint dx 2e^ileft(u - vright)xfracleft(W - sqrtW - 1sqrtW + 1right)^u+vpm 1sqrtW - 1sqrtW + 1","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"The individual elements of the full real-space Green's function are","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"mathcalG_z^jk\n=  G_0z^jk+sum_lmG_0z^jlleftleft left(Delta +  VGamma_0zV^daggerright)^-1-\nG_0zright^-1right_lmG_0z^mk","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"where G_0z^jk are the appropriate elements of the 2times 2 G_0z(mathbfR_kj) blocks.","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"As written, the sum over l and m includes all the atoms in the system. However, the expression can be made considerably simpler. The term Delta + VGamma_0zV^dagger is a square matrix including all the system atoms. Let us rearrange the elements in the matrix to give it a block diagonal form:","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"Delta + VGamma_0zV^dagger rightarrow beginpmatrix000Fendpmatrix","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"where we created a square matrix F that contains only the perturbed atoms. Consequently,","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"left(Delta + VGamma_0zV^daggerright)^-1 rightarrow beginpmatrixinfty 00F^-1endpmatrix","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"and","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"left left(Delta +  VGamma_0zV^daggerright)^-1-\nG_0zright^-1 rightarrow beginpmatrix0 00 leftF^-1 - tildeG_0zright^-1endpmatrix","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"where tildeG_0z is a portion of G_0z that only includes the perturbed atoms. Hence, the lm summation only needs to run over the perturbed atoms, too:","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"mathcalG_z^jk\n=  G_0z^jk+sum_lminmathrmpertG_0z^jlleftleft left(tildeDelta +  tildeVGamma_0ztildeV^daggerright)^-1-\ntildeG_0zright^-1right_lmG_0z^mk","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"Here, the tilde over the matrices indicates that only the elements corresponding to the perturbed atoms are retained. Note that a particular atom is included in tildeV and tildeDelta even if it is perturbed by only one of the terms!","category":"page"},{"location":"formalism.html#Impurity-Green's-Function","page":"Formalism","title":"Impurity Green's Function","text":"","category":"section"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"To calculate the full impurity Green's function, denoted by Gamma_z, we write","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"Gamma_z = leftGamma^-1_0z - V^dagger left(z - H_0 - Deltaright)^-1Vright^-1 = left1 - Gamma_0zV^dagger left(z - H_0 - Deltaright)^-1Vright^-1Gamma_0z\n\n= Gamma_0z + Gamma_0zV^daggerLambda_zleft(1-VGamma_0zV^dagger Lambda_zright)^-1VGamma_0z","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"where","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"Lambda_z = left(z - H_0 - Deltaright)^-1 = left1 - left(z - H_0right)^-1Deltaright^-1 left(z - H_0right)^-1 =left(1 - G_0zDeltaright)^-1 G_0z","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"Similarly to the discussion above, we only need to include the graphene atoms that are perturbed in the Lambda and V matrices. This yields","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"Gamma_z\n= Gamma_0z + Gamma_0ztildeV^daggertildeLambda_zleft(1-tildeVGamma_0ztildeV^dagger tildeLambda_zright)^-1tildeVGamma_0z","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"where","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"tildeLambda_z =left(1 - tildeG_0ztildeDeltaright)^-1tildeG_0z","category":"page"},{"location":"formalism.html#Free-Energy","page":"Formalism","title":"Free Energy","text":"","category":"section"},{"location":"formalism.html#Occupation-Number","page":"Formalism","title":"Occupation Number","text":"","category":"section"},{"location":"api.html#API","page":"API","title":"API","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"Modules = [GrapheneQFT]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"api.html#Pristine-Graphene","page":"API","title":"Pristine Graphene","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"  GrapheneCoord\n  ImpurityState\n  GrapheneSystem\n  graphene_neighbors\n  graphene_multiple_neighbors\n  crystal_to_cartesian\n  noimps\n  nopert\n  mkGrapheneSystem\n  peierls_phase","category":"page"},{"location":"api.html#GrapheneQFT.GrapheneCoord","page":"API","title":"GrapheneQFT.GrapheneCoord","text":"GrapheneCoord(u::Int, v::Int, sublattice::Sublattice)\n\nLattice coordinate of a carbon atom.\n\nEach coordinate contains the sublattice index A or B, as well as the integer coefficients of the two basis vectors dtimes(pm 1 hatx + sqrt3haty)  2 (u for +, v for -), with d = 246Å as the lattice constant.\n\n\n\n\n\n","category":"type"},{"location":"api.html#GrapheneQFT.ImpurityState","page":"API","title":"GrapheneQFT.ImpurityState","text":"ImpurityState(ϵ::Float64, coupling::Vector{Tuple{Float64,GrapheneCoord}})\n\nAn impurity state of energy ϵ (in eV) coupled to the graphene system. The tuples in the coupling field contain all the coupling energies (in eV) and the  corresponding GrapheneCoord's.\n\n\n\n\n\n","category":"type"},{"location":"api.html#GrapheneQFT.GrapheneSystem","page":"API","title":"GrapheneQFT.GrapheneSystem","text":"GrapheneSystem(\n    μ::Float64,\n    T::Float64,\n    Δ::Array{ComplexF64,2},\n    V::Array{Float64,2},\n    scattering_atoms::Vector{GrapheneCoord},\n    imps::Vector{Float64},\n)\n\nA structure describing the perturbed graphene system.\n\nSee also mkGrapheneSystem.\n\n\n\n\n\n","category":"type"},{"location":"api.html#GrapheneQFT.graphene_neighbors","page":"API","title":"GrapheneQFT.graphene_neighbors","text":"graphene_neighbors(atom::GrapheneCoord)\n\nDetermine the nearest neighbors of an atom and return a vector of the correspoding GrapheneCoord's.\n\n\n\n\n\n","category":"function"},{"location":"api.html#GrapheneQFT.graphene_multiple_neighbors","page":"API","title":"GrapheneQFT.graphene_multiple_neighbors","text":"graphene_multiple_neighbors(atom::GrapheneCoord, n::Int)\n\nReturn an array of GrapheneCoord's obtained by iteratively running graphene_neighbors n times, applying it only to the newly-added GrapheneCoord's from the past iteration. The entries in the result are unique and sorted by their distance from atom.\n\nArguments\n\natom: GrapheneCoord from which the iteration begins\nn: number of iterations of graphene_neighbors.\n\n\n\n\n\n","category":"function"},{"location":"api.html#GrapheneQFT.crystal_to_cartesian","page":"API","title":"GrapheneQFT.crystal_to_cartesian","text":"crystal_to_cartesian(coord::GrapheneCoord)\n\nConvert a GrapheneCoord to a cartesian point with lengths in Å, where GrapheneCoord(0, 0, A) is at the origin.\n\n\n\n\n\n","category":"function"},{"location":"api.html#GrapheneQFT.noimps","page":"API","title":"GrapheneQFT.noimps","text":"const noimps = ImpurityState[]\n\nAn empty array to be used in constructing the GrapheneSystem if there are no impurity states.\n\n\n\n\n\n","category":"constant"},{"location":"api.html#GrapheneQFT.nopert","page":"API","title":"GrapheneQFT.nopert","text":"const nopert = Tuple{GrapheneCoord,GrapheneCoord,ComplexF64}[]\n\nAn empty array to be used in constructing the GrapheneSystem if there are no direct perturbation terms.\n\n\n\n\n\n","category":"constant"},{"location":"api.html#GrapheneQFT.mkGrapheneSystem","page":"API","title":"GrapheneQFT.mkGrapheneSystem","text":"mkGrapheneSystem(\n    μ::Float64,\n    T::Float64,\n    imps::Vector{ImpurityState},\n    pert::Vector{Tuple{GrapheneCoord,GrapheneCoord,ComplexF64}},\n)\n\nConstruct GrapheneSystem.\n\nArguments\n\nμ: chemical potential\nT: temperature\nimps: a list of [ImpurityState]'s\npert: a list of 3-tuples describing the coupling between carbon atoms\n\nWhen supplying pert, ensure that each coordinate pair appears only once as repeated pairs with different couplings will cause eariler values to be overwritten. The order of the coordinates does not matter. A tuple with the same coordinate given twice creates and on-site potential for the coordinate.\n\nThe function constructs a GrapheneSystem with the Δ and V matrix computed from imps and pert. In addition, a list of all GrapheneCoord that are perturbed (scattering_atoms field in GrapheneCoord) and a list of impurity energies (imps field in GrapheneCoord) are included.\n\n\n\n\n\n","category":"function"},{"location":"api.html#GrapheneQFT.peierls_phase","page":"API","title":"GrapheneQFT.peierls_phase","text":"peierls_phase(vec_pot, a1::GrapheneCoord, a2::GrapheneCoord)\n\nCalculate the phase used in the Peierls substitution to include the effects of the magnetic field.\n\nTo make the units work out better, the magnetic field mathbfB(x y z) = Phi_0mathcalV mathbff(x y z), where mathcalV is the area of the graphene unit cell in Å², Phi_0 = h  2e is the magnetic flux quantum, and mathbff(x y z) = nabla times mathbfg(xyz) is a dimensionless vector function. Note that mathbff = 1 produces a field of about 40000 T.\n\nFor the vector potential, we have mathbfA(x y z) =Phi_0  mathcalV mathbfg(x y z), where mathbfg(x y z) has the units of Å. Using the definition of the Peierls phase, one gets\n\nphi = -fracpi Phi_0 int mathbfAcdot dmathbfl =\n-fracpi mathcalV int  mathbfg(x y z) cdot dmathbfl\nrightarrow\n-fracpi mathcalV int  mathbfg_xy(x y) cdot dmathbfl\n\nThe last step follows from the fact that the graphene system resides in the xy plane, so one needs to retain only the x and y componends of mathbfg, as denoted by the subscript xy.\n\nArguments\n\nvec_pot(x,y): mathbfg_xy(x y) in Å with x and y in Å.\na1: GrapheneCoord of the \"from\" atom.\na2: GrapheneCoord of the \"to\" atom.\n\nvec_pot(x,y) needs to return a tuple corresponding to the vector potential in     x and y directions.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Green's-Functions","page":"API","title":"Green's Functions","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"  δG_R\n  G_R\n  δΓ\n  Γ","category":"page"},{"location":"api.html#GrapheneQFT.δG_R","page":"API","title":"GrapheneQFT.δG_R","text":"δG_R(z::ComplexF64,\n pairs::Vector{Tuple{GrapheneCoord,GrapheneCoord}},\n s::GrapheneSystem)\n\nThe correction to the real-space graphene Green's function in the presence of defects as a function of complex energy z.\n\nThe function returns a vector of ComplexF64 for each GrapheneCoord     in pairs.\n\nArguments\n\nz: complex energy\npairs: pairs of GrapheneCoord's for which δG_R is calculated\ns: GrapheneSystem for which δG_R is calculated\n\n\n\n\n\n","category":"function"},{"location":"api.html#GrapheneQFT.G_R","page":"API","title":"GrapheneQFT.G_R","text":"G_R(z::ComplexF64,\npairs::Vector{Tuple{GrapheneCoord,GrapheneCoord}},\ns::GrapheneSystem)\n\nThe full real-space graphene Green's function in the presence of defects as a function of complex energy z.\n\nArguments\n\nz: complex energy\npairs: pairs of GrapheneCoord's for which G_R is calculated\ns: GrapheneSystem for which G_R is calculated\n\n\n\n\n\n","category":"function"},{"location":"api.html#GrapheneQFT.δΓ","page":"API","title":"GrapheneQFT.δΓ","text":"δΓ(z::ComplexF64, s::GrapheneSystem)\n\nThe correction to the impurity Green's function due to the impurities' interaction with graphene.\n\nArguments\n\nz: complex energy\ns: GrapheneSystem for which δΓ is calculated\n\n\n\n\n\n","category":"function"},{"location":"api.html#GrapheneQFT.Γ","page":"API","title":"GrapheneQFT.Γ","text":"Γ(z::ComplexF64, s::GrapheneSystem)\n\nThe full impurity Green's function with the correction due to the impurities' interaction with graphene.\n\nArguments\n\nz: complex energy\ns: GrapheneSystem for which Γ is calculated\n\n\n\n\n\n","category":"function"},{"location":"api.html#Carbon-Orbitals","page":"API","title":"Carbon Orbitals","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"  Ψ_pz\n  coulomb_potential_pz\n  coulomb_potential_pz_interp\n  coulomb_energy_pz_pz","category":"page"},{"location":"api.html#GrapheneQFT.Ψ_pz","page":"API","title":"GrapheneQFT.Ψ_pz","text":"Ψ_pz(r::Float64, θ::Float64)\n\n2pz orbital in spherical coordinates.\n\nThe radial part is extracted from DFT, while the angular portion is the spherical harmonic for 2pz (n=2, l=1, m=0) is cos(θ). The wave function does not depend on ϕ, as expected for a pz orbital.\n\nArguments\n\nr: radial distance from the center of the orbital in Bohr radii\nθ: polar angle\n\nNote that the function returns 0 for r > 40 since the radial component at r = 40 is ≈4.5×10⁻¹¹.\n\n\n\n\n\n","category":"function"},{"location":"api.html#GrapheneQFT.coulomb_potential_pz","page":"API","title":"GrapheneQFT.coulomb_potential_pz","text":"coulomb_potential_pz(R::Float64, τ::Float64)\n\nCoulomb potential generated by a 2pz orbital at distance R and polar angle τ from the center of the orbital.\n\n\n\n\n\n","category":"function"},{"location":"api.html#GrapheneQFT.coulomb_potential_pz_interp","page":"API","title":"GrapheneQFT.coulomb_potential_pz_interp","text":"coulomb_potential_pz_interp(R::Float64, τ::Float64)\n\nInterpolated version of coulomb_potential_pz.\n\nSince calculating coulomb_potential_pz involves computing a 3D integral, multiple calculations can be costly. Therefore, this function uses a precomputed grid to approximate coulomb_potential_pz for scenarios when the direct calculation becomes not feasible.\n\n\n\n\n\n","category":"function"},{"location":"api.html#GrapheneQFT.coulomb_energy_pz_pz","page":"API","title":"GrapheneQFT.coulomb_energy_pz_pz","text":"coulomb_energy_pz_pz(ρ::Tuple{Float64, Float64, Float64})\n\nCoulomb interaction between two graphene orbitals.\n\nArguments\n\nρ: a 3-tuple separation vector (x,y,z) between the orbital centers\n\n\n\n\n\n","category":"function"},{"location":"index.html#GrapheneQFT.jl","page":"Home","title":"GrapheneQFT.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"  GrapheneQFT","category":"page"},{"location":"index.html#GrapheneQFT","page":"Home","title":"GrapheneQFT","text":"This package provides provides a set of functions to facilitate the field-theoretic treatment of monolayer graphene using the tight-binding model. The Hamiltonian employed by this package includes only the nearest-neighbor hopping term with t = 28eV. The derivation of the formalism is available here.\n\n\n\n\n\n","category":"module"}]
}

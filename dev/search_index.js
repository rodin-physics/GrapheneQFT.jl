var documenterSearchIndex = {"docs":
[{"location":"formalism.html#Formalism","page":"Formalism","title":"Formalism","text":"","category":"section"},{"location":"api.html#API","page":"API","title":"API","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"Modules = [GrapheneQFT]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"api.html","page":"API","title":"API","text":"  GrapheneCoord\n  ImpurityState\n  GrapheneSystem\n  graphene_A\n  graphene_B\n  graphene_neighbors\n  graphene_multiple_neighbors\n  crystal_to_cartesian\n  noimps\n  nopert\n  mkGrapheneSystem\n  δG_R\n  G_R\n  δΓ\n  Γ\n  Ψ_pz\n  coulomb_potential_pz\n  coulomb_potential_pz_interp\n  coulomb_energy_pz_pz","category":"page"},{"location":"api.html#GrapheneQFT.GrapheneCoord","page":"API","title":"GrapheneQFT.GrapheneCoord","text":"GrapheneCoord(u::Int, v::Int, sublattice::Sublattice)\n\nLattice coordinate of a carbon atom, generated using graphene_A or graphene_B.\n\nEach coordinate contains the sublattice index A or B, as well as the integer coefficients of the two basis vectors dtimes(pm 1 hatx + sqrt3haty)  2 (u for +, v for -), with d = 246Å as the lattice constant.\n\n\n\n\n\n","category":"type"},{"location":"api.html#GrapheneQFT.ImpurityState","page":"API","title":"GrapheneQFT.ImpurityState","text":"ImpurityState(ϵ::Float64, coupling::Vector{Tuple{Float64,GrapheneCoord}})\n\nAn impurity state of energy ϵ (in eV) coupled to the graphene system. The tuples in the coupling field contain all the coupling energies (in eV) and the  corresponding GrapheneCoord's.\n\n\n\n\n\n","category":"type"},{"location":"api.html#GrapheneQFT.GrapheneSystem","page":"API","title":"GrapheneQFT.GrapheneSystem","text":"GrapheneSystem(\n    μ::Float64,\n    T::Float64,\n    Δ::Array{ComplexF64,2},\n    V::Array{Float64,2},\n    scattering_atoms::Vector{GrapheneCoord},\n    imps::Vector{Float64},\n)\n\nA structure describing the perturbed graphene system.\n\nSee also mkGrapheneSystem.\n\n\n\n\n\n","category":"type"},{"location":"api.html#GrapheneQFT.graphene_A","page":"API","title":"GrapheneQFT.graphene_A","text":"graphene_A(u::Int, v::Int)\n\nCreate a GrapheneCoord for an atom belonging to sublattice A at the unit cell (u, v).\n\n\n\n\n\n","category":"function"},{"location":"api.html#GrapheneQFT.graphene_B","page":"API","title":"GrapheneQFT.graphene_B","text":"graphene_B(u::Int, v::Int)\n\nCreate a GrapheneCoord for an atom belonging to sublattice B at the unit cell (u, v).\n\n\n\n\n\n","category":"function"},{"location":"api.html#GrapheneQFT.graphene_neighbors","page":"API","title":"GrapheneQFT.graphene_neighbors","text":"graphene_neighbors(atom::GrapheneCoord)\n\nDetermine the nearest neighbors of an atom and return a vector of the correspoding GrapheneCoord's.\n\n\n\n\n\n","category":"function"},{"location":"api.html#GrapheneQFT.graphene_multiple_neighbors","page":"API","title":"GrapheneQFT.graphene_multiple_neighbors","text":"graphene_multiple_neighbors(atom::GrapheneCoord, n::Int)\n\nReturn an array of GrapheneCoord's obtained by iteratively running graphene_neighbors n times, applying it only to the newly-added GrapheneCoord's from the past iteration. The entries in the result are unique and sorted by their distance from atom.\n\nArguments\n\natom: GrapheneCoord from which the iteration begins\nn: number of iterations of graphene_neighbors.\n\n\n\n\n\n","category":"function"},{"location":"api.html#GrapheneQFT.crystal_to_cartesian","page":"API","title":"GrapheneQFT.crystal_to_cartesian","text":"crystal_to_cartesian(coord::GrapheneCoord)\n\nConvert a GrapheneCoord to a cartesian point with lengths in Å, where GrapheneCoord(0, 0, A) is at the origin.\n\n\n\n\n\n","category":"function"},{"location":"api.html#GrapheneQFT.noimps","page":"API","title":"GrapheneQFT.noimps","text":"const noimps = ImpurityState[]\n\nAn empty array to be used in constructing the GrapheneSystem if there are no impurity states.\n\n\n\n\n\n","category":"constant"},{"location":"api.html#GrapheneQFT.nopert","page":"API","title":"GrapheneQFT.nopert","text":"const nopert = Tuple{GrapheneCoord,GrapheneCoord,ComplexF64}[]\n\nAn empty array to be used in constructing the GrapheneSystem if there are no direct perturbation terms.\n\n\n\n\n\n","category":"constant"},{"location":"api.html#GrapheneQFT.mkGrapheneSystem","page":"API","title":"GrapheneQFT.mkGrapheneSystem","text":"mkGrapheneSystem(\n    μ::Float64,\n    T::Float64,\n    imps::Vector{ImpurityState},\n    pert::Vector{Tuple{GrapheneCoord,GrapheneCoord,ComplexF64}},\n)\n\nConstruct GrapheneSystem.\n\nArguments\n\nμ: chemical potential\nT: temperature\nimps: a list of [ImpurityState]'s\npert: a list of 3-tuples describing the coupling between carbon atoms\n\nWhen supplying pert, ensure that each coordinate pair appears only once as repeated pairs with different couplings will cause eariler values to be overwritten. The order of the coordinates does not matter. A tuple with the same coordinate given twice creates and on-site potential for the coordinate.\n\nThe function constructs a GrapheneSystem with the Δ and V matrix computed from imps and pert. In addition, a list of all GrapheneCoord that are perturbed (scattering_atoms field in GrapheneCoord) and a list of impurity energies (imps field in GrapheneCoord) are included.\n\n\n\n\n\n","category":"function"},{"location":"api.html#GrapheneQFT.δG_R","page":"API","title":"GrapheneQFT.δG_R","text":"δG_R(z::ComplexF64,\n pairs::Vector{Tuple{GrapheneCoord,GrapheneCoord}},\n s::GrapheneSystem)\n\nThe correction to the real-space graphene Green's function in the presence of defects as a function of complex energy z.\n\nThe function returns a vector of ComplexF64 for each GrapheneCoord     in pairs.\n\nArguments\n\nz: complex energy\npairs: pairs of GrapheneCoord's for which δG_R is calculated\ns: GrapheneSystem for which δG_R is calculated\n\n\n\n\n\n","category":"function"},{"location":"api.html#GrapheneQFT.G_R","page":"API","title":"GrapheneQFT.G_R","text":"G_R(z::ComplexF64,\npairs::Vector{Tuple{GrapheneCoord,GrapheneCoord}},\ns::GrapheneSystem)\n\nThe full real-space graphene Green's function in the presence of defects as a function of complex energy z.\n\nArguments\n\nz: complex energy\npairs: pairs of GrapheneCoord's for which G_R is calculated\ns: GrapheneSystem for which G_R is calculated\n\n\n\n\n\n","category":"function"},{"location":"api.html#GrapheneQFT.δΓ","page":"API","title":"GrapheneQFT.δΓ","text":"δΓ(z::ComplexF64, s::GrapheneSystem)\n\nThe correction to the impurity Green's function due to the impurities' interaction with graphene.\n\nArguments\n\nz: complex energy\ns: GrapheneSystem for which δΓ is calculated\n\n\n\n\n\n","category":"function"},{"location":"api.html#GrapheneQFT.Γ","page":"API","title":"GrapheneQFT.Γ","text":"Γ(z::ComplexF64, s::GrapheneSystem)\n\nThe full impurity Green's function with the correction due to the impurities' interaction with graphene.\n\nArguments\n\nz: complex energy\ns: GrapheneSystem for which Γ is calculated\n\n\n\n\n\n","category":"function"},{"location":"api.html#GrapheneQFT.Ψ_pz","page":"API","title":"GrapheneQFT.Ψ_pz","text":"Ψ_pz(r::Float64, θ::Float64)\n\n2pz orbital in spherical coordinates.\n\nThe radial part is extracted from DFT, while the angular portion is the spherical harmonic for 2pz (n=2, l=1, m=0) is cos(θ). The wave function does not depend on ϕ, as expected for a pz orbital.\n\nArguments\n\nr: radial distance from the center of the orbital in Bohr radii\nθ: polar angle\n\nNote that the function returns 0 for r > 40 since the radial component at r = 40 is ≈4.5×10⁻¹¹.\n\n\n\n\n\n","category":"function"},{"location":"api.html#GrapheneQFT.coulomb_potential_pz","page":"API","title":"GrapheneQFT.coulomb_potential_pz","text":"coulomb_potential_pz(R::Float64, τ::Float64)\n\nCoulomb potential generated by a 2pz orbital at distance R and polar angle τ from the center of the orbital.\n\n\n\n\n\n","category":"function"},{"location":"api.html#GrapheneQFT.coulomb_potential_pz_interp","page":"API","title":"GrapheneQFT.coulomb_potential_pz_interp","text":"coulomb_potential_pz_interp(R::Float64, τ::Float64)\n\nInterpolated version of coulomb_potential_pz.\n\nSince calculating coulomb_potential_pz involves computing a 3D integral, multiple calculations can be costly. Therefore, this function uses a precomputed grid to approximate coulomb_potential_pz for scenarios when the direct calculation becomes not feasible.\n\n\n\n\n\n","category":"function"},{"location":"api.html#GrapheneQFT.coulomb_energy_pz_pz","page":"API","title":"GrapheneQFT.coulomb_energy_pz_pz","text":"coulomb_energy_pz_pz(ρ::Tuple{Float64, Float64, Float64})\n\nCoulomb interaction between two graphene orbitals.\n\nArguments\n\nρ: a 3-tuple separation vector (x,y,z) between the orbital centers\n\n\n\n\n\n","category":"function"},{"location":"index.html#GrapheneQFT.jl","page":"Home","title":"GrapheneQFT.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"  GrapheneQFT","category":"page"},{"location":"index.html#GrapheneQFT","page":"Home","title":"GrapheneQFT","text":"This package provides provides a set of functions to facilitate the field-theoretic treatment of monolayer graphene using the tight-binding model. The Hamiltonian employed by this package includes only the nearest-neighbor hopping term with t = 28eV. The derivation of the formalism is available here.\n\nExample:\n\nPick a few graphene coordinates:\n\na1 = graphene_A(0, 17)\na2 = graphene_A(1, 1)\na3 = graphene_B(3, -2)\na4 = graphene_A(2, 7)\na5 = graphene_A(0, 1)\n\nNext, initialize a couple of impurities and couple them to the coordinates:\n\nϵ1 = 1.7\nϵ2 = -0.2\n\nV1 = 0.4\nV2 = 2.0\nV3 = -7.1\n\nimp1 = ImpurityState(ϵ1, [(V1, a4), (V2, a3)])\nimp2 = ImpurityState(ϵ2, [(V3, a5)])\n\nCreate a few coupling integrals c and use them to create some perturbations\n\nc1 = 3.0\nc2 = 5.0\nc3 = -9.0\n\np1 = (a1, a1, c1)\np2 = (a2, a1, c2)\np3 = (a3, a1, c3)\n\nFinally, initialize the system:\n\nμ = 0.2\nT = 0.0\n\nmy_system = mkGrapheneSystem(μ, T, [imp1, imp2], [p1, p2, p3])\n\nmy_system can now be used to calculate the relevant Green's functions (δG_R, G_R, δΓ, Γ), from which quantities of interest can be computed.\n\n\n\n\n\n","category":"module"}]
}

var documenterSearchIndex = {"docs":
[{"location":"formalism.html#Formalism","page":"Formalism","title":"Formalism","text":"","category":"section"},{"location":"formalism.html#General-System","page":"Formalism","title":"General System","text":"","category":"section"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"Instead of starting directly with the problem of defects in graphene, we start with a more general scenario which will make the derivation more transparent. Consider a pristine system described by a second-quantized Hamiltonian sum_jk c^dagger_j H_jkc_k, where j and k label the states of the system, c_j and c_j^dagger are the corresponding annihilation and creation operators, and H_jk gives the coupling between the states. Next, we introduce two types of perturbation to this system. First, we can modify the coupling between the states. Second, we introduce a second system described by a Hamiltonian sum_jk g^dagger_j h_jkg_k and couple it to the original one. The total Hamiltonian, then, can be written as","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"hatmathcalH = sum_jk c^dagger_j H_jkc_k\n    +\n    sum_jk c^dagger_j Delta_jkc_k\n    +\n    sum_jk left(c^dagger_j V_jkg_k + g^dagger_k V_jk^* c_jright)\n    +\n    sum_jk g^dagger_j h_jkg_k","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"where the second term in the first line describes the modified coupling in the original system and the first term in the second line gives the coupling between the two systems. The Hamiltonian can be written more compactly if we assemble the operators and the coupling elements into vectors and matrices, respectively:","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"hatmathcalH = mathbfc^dagger Hmathbfc + mathbfc^dagger Delta mathbfc\n    +left(mathbfc^dagger Vmathbfg + mathbfg^dagger V^dagger mathbfcright) + mathbfg^dagger hmathbfg","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"Next, we transcribe the Hamiltonian into the imaginary-time action","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"S = sum_nbarboldsymbolpsi_n overbraceleft(-iomega_n - mu + Hright)^-G^-1_iomega_n + muboldsymbolpsi_n + barboldsymbolpsi_nDelta boldsymbolpsi_n\n    +left(barboldsymbolpsi_n Vboldsymbolphi_n + barboldsymbolphi_n V^dagger boldsymbolpsi_nright) + barboldsymbolphi_n overbraceleft(-iomega_n - mu + hright)^-Gamma_iomega_n+mu^-1boldsymbolphi_n\n\t\n\t=\n\tsum_n\n\tbeginpmatrix\n\tbarboldsymbolpsi_n  barboldsymbolphi_n\n\tendpmatrix\n\tbeginpmatrix\n        -G_iomega_n+mu^-1 + Delta  V\n        \n        V^dagger  -Gamma_iomega_n+mu^-1\n    endpmatrix\n\tbeginpmatrix\n\tboldsymbolpsi_n  boldsymbolphi_n\n\tendpmatrix\n\t","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"where omega_n are the fermionic Matsubara frequencies, mu is the chemical potential, and boldsymbolphi_n and boldsymbolpsi_n (barboldsymbolphi_n and barboldsymbolpsi_n) are vectors of Grassmann numbers corresponding to mathbfg and mathbfc (mathbfg^dagger and mathbfc^dagger). We also identify G_z and Gamma_z as the Green's functions for the two systems.","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"Exponentiating -S and integrating over all the Grassmann variables yields the partition function","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"mathcalZ\n    =prod_n\n    leftbeta\n    beginpmatrix\n        -G_iomega_n+mu^-1 + Delta  V\n        \n        V^dagger  -Gamma_iomega_n+mu^-1\n    endpmatrix\n    right","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"where beta = 1  (k_BT). We can identify the full system Green's function from the determinant in mathcalZ","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"mathbfG_z\n    =\n    beginpmatrix\n        G_z^-1 - Delta  -V\n        \n        -V^dagger  Gamma_z^-1\n    endpmatrix^-1\n    =\n    beginpmatrix\n         mathcalG_z  mathcalG_z V Gamma_z\n        \n         Gamma_zV^dagger mathcalG_z  Gamma_z+ Gamma_zV^dagger mathcalG_z V Gamma_z\n    endpmatrix","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"where","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"mathcalG_z\n    =left(G_z^-1 - Delta - VGamma_z V^daggerright)^-1\n    = G_z+G_zleft(Delta + VGamma_z V^daggerright)\n\tleft1-G_zleft(Delta + VGamma_z V^daggerright)right^-1G_z ","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"is the full Green's function of the bulk system including the effects of defects and perturbations. Similarly, the bottom right block in mathbfG_z corresponds to the full Green's function of the impurity states including their coupling to the perturbed bulk system:","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"Gamma_z + Gamma_z V^dagger mathcalG_z V Gamma_z\n= Gamma_z + Gamma_z V^dagger G_z left1 - (Delta + V Gamma_z V^dagger) G_z right^-1 V Gamma_z  ","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"From the partition function, we can also write down the Helmholtz free energy F = -beta^-1 ln mathcalZ:","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"F = -beta^-1sum_n lnleftbeta\n    beginpmatrix\n        -G_iomega_n+mu^-1 + Delta  V\n        \n        V^dagger  -Gamma_iomega_n+mu^-1\n    endpmatrix\n    right\n    \n    = -beta^-1sum_n lnBiggbeta\n    beginpmatrix\n        -G_iomega_n+mu^-1  0\n        \n        0  -Gamma_iomega_n+mu^-1\n    endpmatrix\n    left\n    1\n    +\n    beginpmatrix\n        -G_iomega_n+mu  0\n        \n        0  -Gamma_iomega_n+mu\n    endpmatrix\n    beginpmatrix\n        Delta  V\n        \n        V^dagger  0\n    endpmatrix\n    right\n    Bigg","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"Removing the part of F corresponding to the free energy of the two isolated system in the absence of any perturbation yields the defect- and coupling-induced modification to F","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"delta F\n    = -beta^-1sum_n lnleft\n    beginpmatrix\n       1- G_iomega_n+muDelta  -G_iomega_n+muV\n        \n       - Gamma_iomega_n+muV^dagger  1\n    endpmatrix\n    right\n    \n    = -beta^-1sum_n lnleft\n      1- G_iomega_n+muleft(Delta+VGamma_iomega_n+muV^daggerright)\n    right","category":"page"},{"location":"formalism.html#Graphene","page":"Formalism","title":"Graphene","text":"","category":"section"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"Having performed the required manipulations for a general system, we now focus on graphene. Because the electronic properties of graphene are dominated by the carbon pi orbitals, the electronic states in a pristine system can be described by mathbfrLrangleotimessigmarangle, where mathbfr is the coordinate of the unit cell hosting the orbital, L is the sublattice of the atom, and sigma is the spin of the electron. This is the basis corresponding to the operators c_k in the derivation above.","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"The next required ingredient is the graphene Green's function G_z. Since G_z = (z - H)^-1, it is a matrix whose elements give the propagation amplitudes between graphene states. The matrix elements can be calculated using","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"langlemathbfr Lotimeslanglesigma(z - hatH)^-1mathbfrLrangleotimessigmarangle = frac1Nsum_mathbfqqlanglemathbfq L otimes langle sigmae^imathbfqcdotmathbfr(z - hatH)^-1e^-imathbfqcdotmathbfrmathbfqLrangleotimessigmarangle","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"where we Fourier-transformed the real-space states so that the sums over the momenta mathbfq and mathbfq run over the entire Brillouin zone. Because the momentum-space Hamiltonian is diagonal in mathbfq and sigma, we can write","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"langlemathbfr Lotimeslanglesigma(z - hatH)^-1mathbfrLrangleotimessigmarangle = frac1Nsum_mathbfqlanglemathbfq Le^imathbfqcdotmathbfr(z - hatH)^-1e^-imathbfqcdotmathbfrmathbfqLrangle delta_sigmasigma\n\n= langle Lfrac1Nsum_mathbfqe^imathbfqcdotleft(mathbfr-mathbfrright)(z - H_mathbfq)^-1Lrangle delta_sigmasigma","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"Using","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"H_mathbfq =beginpmatrix 0  -t f_mathbfq  -t f^*_mathbfq  0endpmatrix ","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"where t = 28eV is the nearest-neighbor hopping integral, f_mathbfq = 1 + e^imathbfqcdotmathbfd_1+e^imathbfqcdotmathbfd_2, and mathbfd_12=dleft(pm1 sqrt3right)2 are the lattice vectors, we have","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"frac1Nsum_mathbfq left(z -  H_mathbfq right)^-1 e^ileft(mathbfr_k - mathbfr_jright)cdotmathbfq  = frac1Nsum_mathbfq\nbeginpmatrix\nz - tf_mathbfq\n\n- tf_mathbfq^*  z\nendpmatrixfrac1z^2 - t^2 leftf_mathbfqright^2 e^imathbfr_kjcdotmathbfq","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"To perform the summation over mathbfq, we first introduce","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"Omega^uv_z =\n\tfrac1Nsum_mathbfqinmathrmBZ\n\tfrac\n\t\te^imathbfqcdot left(umathbfd_1 + vmathbfd_2right)\n\t\n\tz^2 - t^2left f_mathbfqright^2","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"with umathbfd_1 + vmathbfd_2 = fracd2left(u - v sqrt3left(u+vright)right). Using mathbfqcdot left(umathbfd_1 + vmathbfd_2right)  = fracd2leftleft(u - vright)q_x + sqrt3left(u+vright)q_yright and turning the momentum sum into an integral yields","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"Omega^uvleft(zright)\n\t= frac1left(2piright)^2oint dx oint dy\n\tfrac\n\te^i leftleft(u - vright)x + left(u+vright)yright\n\tz^2 - t^2left(1 + 4cos^2 x + 4 cos xcos y right)","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"From","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"oint dtheta frace^ilthetaW-costheta = 2pi fracleft(W - sqrtW - 1sqrtW + 1right)^lsqrtW - 1sqrtW + 1","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"we get","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"Omega^uv_z = frac12pifrac14t^2\n\toint dx frace^ileft(u - vright)xcos xfracleft(W - sqrtW - 1sqrtW + 1right)^u+vsqrtW - 1sqrtW + 1\n\t\n\tW = fracfracz^2t^2-14cos x-cos x","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"Finally, for mathbfr = umathbfd_1 + vmathbfd_2, we have","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"frac1Nsum_mathbfq left(z -  H_mathbfq right)^-1 e^imathbfrcdotmathbfq  \n\t=\n\tbeginpmatrix\n\t\tzOmega^uv_z\n\t\t\n\t\t- tleftOmega^uv_z + Omega^uv_+z right\n\t\t\n\t\t- tleftOmega^uv_z + Omega^uv_-zright\n\t\t\n\t\tzOmega^uv_z\n\tendpmatrix\n\t\n\tOmega^uv_pmz\n\t=\n\t frac12pifrac14t^2\n\toint dx 2e^ileft(u - vright)xfracleft(W - sqrtW - 1sqrtW + 1right)^u+vpm 1sqrtW - 1sqrtW + 1","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"Using the multiples of the basis vectors to describe the electronic states (mathbfrLrangleotimessigmaranglerightarrow u v Lrangleotimessigmarangle), the matrix elements langle u v Lotimeslanglesigma(z - hatH)^-1u v Lrangleotimessigmarangle of the Green's function become","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"langle Lbeginpmatrix\n\t\tzOmega^u-uv-v_z\n\t\t\n\t\t- tleftOmega^u-uv-v_z + Omega^u-uv-v_+z right\n\t\t\n\t\t- tleftOmega^u-uv-v_z + Omega^u-uv-v_-zright\n\t\t\n\t\tzOmega^u-uv-v_z\n\tendpmatrixLrangle delta_sigmasigma","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"Depending on the sublattices of the two states, we pick out the appropriate element of the 2times 2 matrix above.","category":"page"},{"location":"formalism.html#Graphene-Green's-Function","page":"Formalism","title":"Graphene Green's Function","text":"","category":"section"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"Following the general derivation above, the individual elements of the full real-space Green's function are","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"mathcalG_z^jk\n=  G_z^jk+sum_lmG_z^jlleftleft left(Delta +  VGamma_zV^daggerright)^-1-\nG_zright^-1right_lmG_z^mk","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"where j, k, l, and m are compact labels for the graphene states u v Lrangleotimessigmarangle. As written, the sum over l and m includes all the states in the system. However, the expression can be made considerably simpler. The term Delta + VGamma_z V^dagger is a square matrix including all the system states. Let us rearrange the elements in the matrix to give it a block diagonal form:","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"Delta + VGamma_zV^dagger rightarrow beginpmatrix000Aendpmatrix","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"where we created a square matrix A that contains only the perturbed states. Consequently,","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"left(Delta + VGamma_zV^daggerright)^-1 rightarrow beginpmatrixinfty 00A^-1endpmatrix","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"and","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"left left(Delta +  VGamma_zV^daggerright)^-1-\nG_zright^-1 rightarrow beginpmatrix0 00 leftA^-1 - tildeG_zright^-1endpmatrix","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"where tildeG_z is a portion of G_z that only includes the perturbed states. Hence, the lm summation only needs to run over these, too:","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"mathcalG_z^jk\n=  G_z^jk+sum_lminmathrmpertG_z^jlleftleft left(tildeDelta +  tildeVGamma_ztildeV^daggerright)^-1-\ntildeG_zright^-1right_lmG_z^mk","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"Here, the tilde over the matrices indicates that only the elements corresponding to the perturbed states are retained. Note that a particular state is included in tildeV and tildeDelta even if it is perturbed by only one of the terms!","category":"page"},{"location":"formalism.html#Impurity-Green's-Function","page":"Formalism","title":"Impurity Green's Function","text":"","category":"section"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"For the full impurity Green's function, we follow the discussion above to obtain","category":"page"},{"location":"formalism.html","page":"Formalism","title":"Formalism","text":"Gamma_z + Gamma_z tildeV^dagger tildeG_z left1 - (tildeDelta + tildeV Gamma_z tildeV^dagger) tildeG_z right^-1 tildeV Gamma_z  ","category":"page"},{"location":"api.html#api","page":"API","title":"API","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"Modules = [GrapheneQFT]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"api.html#Pristine-Graphene","page":"API","title":"Pristine Graphene","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"  GrapheneCoord\n  GrapheneState\n  Defect\n  ImpurityState\n  LocalSpin\n  Hopping\n  GrapheneSystem\n  graphene_neighbors\n  graphene_multiple_neighbors\n  crystal_to_cartesian\n  mkGrapheneSystem\n  peierls_phase","category":"page"},{"location":"api.html#GrapheneQFT.GrapheneCoord","page":"API","title":"GrapheneQFT.GrapheneCoord","text":"GrapheneCoord(u::Int, v::Int, sublattice::Sublattice)\n\nLattice coordinate of a carbon atom.\n\nEach coordinate contains the sublattice index A or B, as well as the integer coefficients of the two basis vectors dtimes(pm 1 hatx + sqrt3haty)  2 (u for +, v for -), with d = 246Å as the lattice constant.\n\n\n\n\n\n","category":"type"},{"location":"api.html#GrapheneQFT.GrapheneState","page":"API","title":"GrapheneQFT.GrapheneState","text":"GrapheneState(coord::GrapheneCoord, spin::Spin)\n\nQuantum state of an electron in graphene, denoted by u v Lrangleotimes sigmarangle in the drivation.\n\nThe state is given by the GrapheneCoord of the orbital, as well as the electronic spin, which can take values SpinUp and SpinDown.\n\n\n\n\n\n","category":"type"},{"location":"api.html#GrapheneQFT.Defect","page":"API","title":"GrapheneQFT.Defect","text":"Defect\n\nAbstract type for all defect types.\n\n\n\n\n\n","category":"type"},{"location":"api.html#GrapheneQFT.ImpurityState","page":"API","title":"GrapheneQFT.ImpurityState","text":"ImpurityState(ϵ::Float64, coupling::Vector{Tuple{Float64,GrapheneCoord}}) <: Defect\n\nAn impurity state of energy ϵ (in eV) coupled to the graphene system. The tuples in the coupling field contain all the coupling energies (in eV) and the  corresponding GrapheneCoord's.\n\n\n\n\n\n","category":"type"},{"location":"api.html#GrapheneQFT.LocalSpin","page":"API","title":"GrapheneQFT.LocalSpin","text":"LocalSpin(x::Float64, y::Float64, z::Float64, coord::GrapheneCoord) <: Defect\n\nA local spin with components x, y, and z located at coord. See GrapheneCoord.\n\n\n\n\n\n","category":"type"},{"location":"api.html#GrapheneQFT.Hopping","page":"API","title":"GrapheneQFT.Hopping","text":"Hopping(c1::GrapheneCoord, c2::GrapheneCoord, Δ::ComplexF64) <: Defect\n\nHopping modification (in eV) between two GrapheneCoord's. If c1==c2,  this quantity corresponds to a local energy modification.\n\n\n\n\n\n","category":"type"},{"location":"api.html#GrapheneQFT.GrapheneSystem","page":"API","title":"GrapheneQFT.GrapheneSystem","text":"GrapheneSystem(\n    μ::Float64,\n    T::Float64,\n    Δ::Array{ComplexF64,2},\n    V::Array{Float64,2},\n    scattering_states::Vector{GrapheneState},\n    imps::Vector{Float64},\n)\n\nA structure describing the perturbed graphene system.\n\nSee also mkGrapheneSystem.\n\n\n\n\n\n","category":"type"},{"location":"api.html#GrapheneQFT.graphene_neighbors","page":"API","title":"GrapheneQFT.graphene_neighbors","text":"graphene_neighbors(atom::GrapheneCoord)\n\nDetermine the nearest neighbors of an atom and return a vector of the corresponding GrapheneCoord's.\n\n\n\n\n\n","category":"function"},{"location":"api.html#GrapheneQFT.graphene_multiple_neighbors","page":"API","title":"GrapheneQFT.graphene_multiple_neighbors","text":"graphene_multiple_neighbors(atom::GrapheneCoord, n::Int)\n\nReturn an array of GrapheneCoord's obtained by iteratively running graphene_neighbors n times, applying it only to the newly-added GrapheneCoord's from the past iteration. The entries in the result are unique and sorted by their distance from atom.\n\nArguments\n\natom: GrapheneCoord from which the iteration begins\nn: number of iterations of graphene_neighbors.\n\n\n\n\n\n","category":"function"},{"location":"api.html#GrapheneQFT.crystal_to_cartesian","page":"API","title":"GrapheneQFT.crystal_to_cartesian","text":"crystal_to_cartesian(coord::GrapheneCoord)\n\nConvert a GrapheneCoord to a cartesian point with lengths in Å, where GrapheneCoord(0, 0, A) is at the origin.\n\n\n\n\n\n","category":"function"},{"location":"api.html#GrapheneQFT.mkGrapheneSystem","page":"API","title":"GrapheneQFT.mkGrapheneSystem","text":"mkGrapheneSystem(\n    μ::Float64,\n    T::Float64,\n    defects::Vector{Defect},\n)\n\nConstruct GrapheneSystem.\n\nArguments\n\nμ: chemical potential\nT: temperature\ndefects: a list of [Defect]'s\n\nWhen supplying []Hopping](@ref) in defects, ensure that each coordinate pair appears only once as repeated pairs with different couplings will cause eariler values to be overwritten. The order of the coordinates does not matter.\n\nThe function constructs a GrapheneSystem with the Δ and V matrices.  In addition, a list of all GrapheneState that are perturbed (scattering_states field in GrapheneCoord) and a list of impurity energies (imps field in GrapheneCoord) are included.\n\n\n\n\n\n","category":"function"},{"location":"api.html#GrapheneQFT.peierls_phase","page":"API","title":"GrapheneQFT.peierls_phase","text":"peierls_phase(vec_pot, a1::GrapheneCoord, a2::GrapheneCoord)\n\nCalculate the phase used in the Peierls substitution to include the effects of the magnetic field.\n\nTo make the units work out better, the magnetic field mathbfB(x y z) = Phi_0mathcalV mathbff(x y z), where mathcalV is the area of the graphene unit cell in Å², Phi_0 = h  2e is the magnetic flux quantum, and mathbff(x y z) = nabla times mathbfg(xyz) is a dimensionless vector function. Note that mathbff = 1 produces a field of about 40000 T.\n\nFor the vector potential, we have mathbfA(x y z) =Phi_0  mathcalV mathbfg(x y z), where mathbfg(x y z) has the units of Å. Using the definition of the Peierls phase, one gets\n\nphi = -fracpi Phi_0 int mathbfAcdot dmathbfl =\n-fracpi mathcalV int  mathbfg(x y z) cdot dmathbfl\nrightarrow\n-fracpi mathcalV int  mathbfg_xy(x y) cdot dmathbfl\n\nThe last step follows from the fact that the graphene system resides in the xy plane, so one needs to retain only the x and y componends of mathbfg, as denoted by the subscript xy.\n\nArguments\n\nvec_pot(x,y): mathbfg_xy(x y) in Å with x and y in Å.\na1: GrapheneCoord of the \"from\" atom.\na2: GrapheneCoord of the \"to\" atom.\n\nvec_pot(x,y) needs to return a tuple corresponding to the vector potential in     x and y directions.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Green's-Functions","page":"API","title":"Green's Functions","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"  δG_R\n  G_R\n  δΓ\n  Γ","category":"page"},{"location":"api.html#GrapheneQFT.δG_R","page":"API","title":"GrapheneQFT.δG_R","text":"δG_R(z::ComplexF64,\n pairs::Vector{Tuple{GrapheneState,GrapheneState}},\n s::GrapheneSystem)\n\nThe correction to the real-space graphene Green's function in the presence of defects as a function of complex energy z.\n\nThe function returns a vector of ComplexF64 for each pair of     GrapheneState's in pairs.\n\nArguments\n\nz: complex energy\npairs: pairs of GrapheneState's for which δG_R is calculated\ns: GrapheneSystem for which δG_R is calculated\n\n\n\n\n\n","category":"function"},{"location":"api.html#GrapheneQFT.G_R","page":"API","title":"GrapheneQFT.G_R","text":"G_R(z::ComplexF64,\npairs::Vector{Tuple{GrapheneState,GrapheneState}},\ns::GrapheneSystem)\n\nThe full real-space graphene Green's function in the presence of defects as a function of complex energy z.\n\nArguments\n\nz: complex energy\npairs: pairs of GrapheneState's for which G_R is calculated\ns: GrapheneSystem for which G_R is calculated\n\n\n\n\n\n","category":"function"},{"location":"api.html#GrapheneQFT.δΓ","page":"API","title":"GrapheneQFT.δΓ","text":"δΓ(z::ComplexF64, s::GrapheneSystem)\n\nThe correction to the impurity Green's function due to the impurities' interaction with graphene.\n\nArguments\n\nz: complex energy\ns: GrapheneSystem for which δΓ is calculated\n\n\n\n\n\n","category":"function"},{"location":"api.html#GrapheneQFT.Γ","page":"API","title":"GrapheneQFT.Γ","text":"Γ(z::ComplexF64, s::GrapheneSystem)\n\nThe full impurity Green's function with the correction due to the impurities' interaction with graphene.\n\nArguments\n\nz: complex energy\ns: GrapheneSystem for which Γ is calculated\n\n\n\n\n\n","category":"function"},{"location":"examples.html#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"CurrentModule = GrapheneQFT\nDocTestSetup  = quote\n    using GrapheneQFT\n    using Plots\nend","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using GrapheneQFT","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using GrapheneQFT\nusing Plots\ngr()","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"The following set of examples focus on extracting experimentally relevant quantities using the functionality provided by GrapheneQFT and visualizing the output. Here, we use Plots.jl although any plotting backend can be used. Note that the syntax for plotting differs across backends.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Pages = [\"examples.md\"]\nDepth = 3","category":"page"},{"location":"examples.html#Spectral-Function","page":"Examples","title":"Spectral Function","text":"","category":"section"},{"location":"examples.html#Single-Line-Plot","page":"Examples","title":"Single Line Plot","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"To calculate the spectral function for graphene, we recall that it is given by -2textrmImG (omega + i0^+ mathbfR), where we use the G_R function to calculate the graphene Green's function. We first define the GrapheneState and GrapheneSystem we are interested in calculating the spectral function for, as well as a range of energies.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using GrapheneQFT#hide\n# Define a state to calculate spectral function for\nstate = GrapheneState(GrapheneCoord(0,1,A), SpinUp)\n\n# Define a GrapheneSystem\npristine_sys = mkGrapheneSystem(0.0, 0.0, Defect[])\n\n# Define range of energies to calculate spectral function for\nωs = range(-9.5, 9.5, step = 0.05)\nnothing#hide","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Next, we can go ahead and calculate the spectral function by mapping the range of energies onto the G_R function.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"# Calculate Green's function for chosen GrapheneState and GrapheneSystem\ngreens_func = map(ω -> G_R(ω + 1im * 1e-6, [(state, state)], pristine_sys)[1], ωs)\n\n# Calculate spectral function\nspec_func = (-2/π) .* imag.(greens_func)\nnothing#hide","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"We plot this and recover the familiar graphene spectral function.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using Plots; gr()\nplot(ωs, spec_func, color = \"blue\", label = \"$state\")","category":"page"},{"location":"examples.html#Multiple-Line-Plots","page":"Examples","title":"Multiple Line Plots","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"The astute reader would have noticed that G_R takes in a vector of GrapheneState Tuples, and the use of [1] in the script was to extract the first (and only) value in the result. The ability to generalize makes it easy to calculate G_R for multiple GrapheneStates simultaneously, with a few manipulations of the data. A more interesting system is used as an example below.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using Plots; gr()#hide\n# Define coordinates and states\nc1 = GrapheneCoord(0,0,A)\nc2 = GrapheneCoord(1,2,B)\n\ns1 = GrapheneState(c1, SpinUp)\ns2 = GrapheneState(c1, SpinDown)\ns3 = GrapheneState(c2, SpinUp)\n\n# Define Defects\nspin1 = LocalSpin(0.0, 0.0, 0.5, c1)\nimp1 = ImpurityState(0.2,[(0.1, c2)])\nhoppings = [Hopping(c1, x, 0.15) for x in graphene_neighbors(c1)]\n\n# Define system with multiple Defects\ntest_sys = mkGrapheneSystem(0.0, 0.0, vcat(spin1, imp1, hoppings))\n\n# Define range of energies to calculate spectral function for\nωs = range(-9.5, 9.5, step = 0.05)\n\n# Calculate Green's function\ngreens_func_all = map(ω -> G_R(ω + 1im * 1e-6, [(s1, s1), (s2, s2), (s3, s3)], test_sys), ωs)\n\n# Calculate and separate individual spectral functions\nspec_func_all = (-2/π) .* imag.(greens_func_all)\nspec_func1 = getindex.(spec_func_all,1)\nspec_func2 = getindex.(spec_func_all,2)\nspec_func3 = getindex.(spec_func_all,3)\n\n# Plotting\nplot(ωs, spec_func1, color = \"blue\", label = \"$s1\")\nplot!(ωs, spec_func2, color = \"red\", label = \"$s2\")\nplot!(ωs, spec_func3, color = \"green\", label = \"$s3\")","category":"page"},{"location":"examples.html#Spatial-Map","page":"Examples","title":"Spatial Map","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"In addition to a line plot of the spectral function across an energy range for a chosen GrapheneState, it is useful to plot spatial maps for a chosen energy. This particular example shows how to build functions on top of the existing functionality. Before the computation, we first define computation settings. These include a grid of GrapheneCoords for both A and B sublattices and a function to calculate the graphene spectral function for a GrapheneState.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using GrapheneQFT, Plots #hide\ngr() #hide\n# Define system chemical potential and temperature\nμ = 0.0\nT = 0.0\n\n# Define grid points and coordinate grids\nnPts = 20\nrange_nPts = -nPts:1:nPts\n\ncoord_A = [GrapheneCoord(u,v,A) for u in range_nPts, v in range_nPts] |> vec\ncoord_B = [GrapheneCoord(u,v,B) for u in range_nPts, v in range_nPts] |> vec\n\n# Define function\nfunction spectral_graphene_spinUp(energy::Float64, coord::GrapheneCoord, sys::GrapheneSystem)\n    state = GrapheneState(coord, SpinUp)\n    res = (-2/π) * G_R(energy + 1im * 1e-6, [(state, state)], sys)\n    return imag(res[1])\nend\nnothing#hide","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"We can now define the system and calculate the spectral function over the coordinate grids.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"# Define coordinates and states\nc1 = GrapheneCoord(0,0,A)\nc1_neighbors = graphene_neighbors(c1)\n\n# Define energy (eV) for spatial map\nω = 0.2\n\n# Define GrapheneSystem with an ImpurityState at c1 and its neighbors\ntest_sys = mkGrapheneSystem(0.1, 0.0, Defect[ImpurityState(0.2, vcat((0.15, c1), [(0.1, x) for x in c1_neighbors]))])\n\n# Calculation\nresA = map(x -> spectral_graphene_spinUp(ω, x, test_sys), coord_A)\nresB = map(x -> spectral_graphene_spinUp(ω, x, test_sys), coord_B)\nsignal = vcat(resA, resB)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"To plot, we make use of the crystal_to_cartesian function to correctly place the carbon atoms.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"c1 = GrapheneCoord(0,0,A) #hide\nc1_neighbors = graphene_neighbors(c1) #hide\nω = 0.2 #hide\ntest_sys = mkGrapheneSystem(0.1, 0.0, Defect[ImpurityState(0.2, vcat((0.15, c1), [(0.1, x) for x in c1_neighbors]))]) #hide\nresA = map(x -> spectral_graphene_spinUp(ω, x, test_sys), coord_A) #hide\nresB = map(x -> spectral_graphene_spinUp(ω, x, test_sys), coord_B) #hide\nsignal = vcat(resA, resB) #hide\n# Define Cartesian coordinates\nA_latt = crystal_to_cartesian.(coord_A)\nB_latt = crystal_to_cartesian.(coord_B)\n\nfull_lattice = vcat(A_latt, B_latt)\nX_latt = first.(full_lattice)\nY_latt = last.(full_lattice)\n\n# Plotting\nscatter(X_latt, Y_latt,\n        marker_z = signal, color = :viridis,\n        markersize = 4, markerstrokewidth = 0,\n        xrange = (-30, 30), yrange = (-30, 30),\n        label = nothing, clims = (0.009, 0.0098),\n        xlabel = \"Distance(Å)\", ylabel = \"Distance(Å)\",\n        guidefontsize = 8, aspectratio = 1)","category":"page"},{"location":"examples.html#Free-Energy","page":"Examples","title":"Free Energy","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"We use the δF function to calculate the variation in system free energy due to the defects.","category":"page"},{"location":"examples.html#Line-Plot","page":"Examples","title":"Line Plot","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"The script below plots how delta F varies as the impurity-lattice coupling strength is tuned in a system with a single ImpurityState.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"# Define impurity energy and coordinate\nϵ = 0.2\nc1 = GrapheneCoord(0,0,A)\n\n# Define function to calculate δF for each coupling strength\nfunction δF_imp_coupling(coup::Float64)\n    imp = ImpurityState(ϵ, [(coup, c1)])\n    test_sys = mkGrapheneSystem(0.0, 0.0, Defect[imp])\n    return δF(test_sys)\nend\n\n# Define range of coupling strengths and map onto values\ncouplings = range(0.0, 0.5, step = 0.01)\nres = map(δF_imp_coupling, couplings)\n\nplot(couplings, res,\n    xlabel = \"Coupling Strength (eV)\",\n    ylabel = \"δF (eV)\", title = \"Single ImpurityState\",\n    guidefontsize = 8, label = nothing)","category":"page"},{"location":"examples.html#Heatmap","page":"Examples","title":"Heatmap","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Similar to above, we can vary both the system's chemical potential and coupling strength to produce a heatmap of delta F values.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"ϵ = 0.2 #hide\nc1 = GrapheneCoord(0,0,A) #hide\n# Define function to calculate δF for each coupling strength\nfunction δF_imp_mu_coupling(mu::Float64, coup::Float64)\n    imp = ImpurityState(ϵ, [(coup, c1)])\n    test_sys = mkGrapheneSystem(mu, 0.0, Defect[imp])\n    return δF(test_sys)\nend\n\n# Define range of coupling strengths and map onto values\ncouplings = range(0.0, 0.5, step = 0.01)\nμ_values = range(0.0, 0.5, step = 0.005)\n\n# Plotting\nheatmap(μ_values, couplings, δF_imp_mu_coupling,\n        xlabel = \"μ (eV)\", ylabel = \"Coupling Strength (eV)\",\n        colorbar_title = \"\\nδF (eV)\", guidefontsize = 8,\n        right_margin = 2.5Plots.mm)","category":"page"},{"location":"examples.html#Charge-Density-Modulation","page":"Examples","title":"Charge Density Modulation","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"The defect-induced variation to the charge density is calculated using the δρ_R_graphene function.","category":"page"},{"location":"examples.html#Line-Plot-2","page":"Examples","title":"Line Plot","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"The script below plots the variation in total delta rho_mathbfR as a function of distance from the impurity in a single-impurity system. The total charge density is given by the sum of spin-resolved charge density values.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"# Define system parameters\nϵ = 0.2\nc1 = GrapheneCoord(0,0,A)\nimp = ImpurityState(0.2, [(0.1, c1)])\ndist = -10:1:10\n\n# Define GrapheneSystem\ntest_sys = mkGrapheneSystem(0.2, 0.0, Defect[imp])\n\n# Calculation for spin-resolved charge density\nres_SpinUp =  map(x -> δρ_R_graphene(GrapheneState(GrapheneCoord(x,0,A), SpinUp), test_sys), dist)\nres_SpinDown =  map(x -> δρ_R_graphene(GrapheneState(GrapheneCoord(x,0,A), SpinDown), test_sys), dist)\n\n# Plotting total charge density variation\nplot(dist, (res_SpinUp .+ res_SpinDown);\n    marker = (:circle, 5), title = \"Total Charge Density Variation\",\n    xlabel = \"Distance (d)\", ylabel = \"δρ (electrons/atom)\",\n    guidefontsize = 8, label = nothing)","category":"page"},{"location":"examples.html#Miscellaneous","page":"Examples","title":"Miscellaneous","text":"","category":"section"},{"location":"examples.html#Animations","page":"Examples","title":"Animations","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"It is often useful to create animations to visualize how a quantity changes with respect to some variable. One of the easiest ways to begin creating animations is to use the @gif and @animate macros in Plots.jl . The script below creates a GIF to show how the spectral function varies as the energy level of an ImpurityState is tuned.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"# Define defect as function that takes in the defect energy\nimp_ener(ϵ) = ImpurityState(ϵ, [(0.8, GrapheneCoord(0,0,A))])\n\n# Define range of energies for defect\nϵs = range(-5.0, 5.0, step = 0.05)\n\n# Define range of energies to calculate spectral function for\nωs = range(-9.0, 9.0, step = 0.05)\n\n# Define spectral function\nfunction spectral_graphene_spinUp(energy::Float64, sys::GrapheneSystem)\n    state = GrapheneState(GrapheneCoord(0,0,A), SpinUp)\n    res = (-2/π) * G_R(energy + 1im * 1e-6, [(state, state)], sys)\n    return imag(res[1])\nend\n\n# Define a plotting function for convenience\nfunction plotter_func(ϵ::Float64)\n    # Define GrapheneSystem\n    test_sys = mkGrapheneSystem(0.1, 0.0, Defect[imp_ener(ϵ)])\n\n    # Calculate and plot spectral function\n    res = map(x -> spectral_graphene_spinUp(x, test_sys), ωs)\n    plot(ωs, res,\n        color = :blue,\n        label = nothing,\n        title = \"ϵ = $ϵ eV\",\n        ylims = (-0.01, 0.9))\nend\n\n# Animation\nanim = @animate for ii in ϵs\n                    plotter_func(ii)\n                end\n\ngif(anim, fps = 20)","category":"page"},{"location":"examples.html#Parallel-Computing","page":"Examples","title":"Parallel Computing","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"The functionality of GrapheneQFT.jl lends itself well to parallel computing, especially with the use of parallel mapping. The module Distributed is an implementation of distributed parallel computing that is part of Julia's standard library. The user manual shows how to use the module and benefit from parallel computing methods such as pmap.","category":"page"},{"location":"basics.html#Basic-Usage","page":"Basics","title":"Basic Usage","text":"","category":"section"},{"location":"basics.html","page":"Basics","title":"Basics","text":"CurrentModule = GrapheneQFT\nDocTestSetup  = quote\n    using GrapheneQFT\nend","category":"page"},{"location":"basics.html","page":"Basics","title":"Basics","text":"using GrapheneQFT","category":"page"},{"location":"basics.html","page":"Basics","title":"Basics","text":"using GrapheneQFT\nusing Plots","category":"page"},{"location":"basics.html","page":"Basics","title":"Basics","text":"To view all functions and macros provided, run","category":"page"},{"location":"basics.html","page":"Basics","title":"Basics","text":"print(names(GrapheneQFT))","category":"page"},{"location":"basics.html","page":"Basics","title":"Basics","text":"We can see that there are many functions provided and it can be easy to not know where to begin. An easy way to access basic documentation for each function is to enter help mode by typing ? into the REPL and typing in the function name.","category":"page"},{"location":"basics.html","page":"Basics","title":"Basics","text":"help?> GrapheneCoord\nsearch: GrapheneCoord\n\n GrapheneCoord(u::Int, v::Int, sublattice::Sublattice)\n\n Lattice coordinate of a carbon atom.\n\n Each coordinate contains the sublattice index A or B, as well as the integer coefficients of the two basis vectors d\\times(\\pm 1 \\hat{x} + \\sqrt{3}\\hat{y}) / 2 (u for +, v for\n -), with d = 2.46Å as the lattice constant.","category":"page"},{"location":"basics.html#Coordinates-and-States-in-Graphene","page":"Basics","title":"Coordinates and States in Graphene","text":"","category":"section"},{"location":"basics.html","page":"Basics","title":"Basics","text":"We begin by learning how to define coordinates and states in graphene using the GrapheneCoord and GrapheneState structs respectively. Entering the help mode and searching for the documentation for GrapheneCoord, as we did above, shows that it is the lattice coordinate for a carbon atom in graphene with three fields: two integers as coefficients of the basis vectors and a sublattice index A or B. We can define coordinates and access their fields using struct_name.field_name:","category":"page"},{"location":"basics.html","page":"Basics","title":"Basics","text":"using GrapheneQFT#hide\nc1 = GrapheneCoord(0, 0, A)\nc2 = GrapheneCoord(2, -5, B)\nc1.u\nc2.v\nc2.sublattice","category":"page"},{"location":"basics.html","page":"Basics","title":"Basics","text":"To define a GrapheneState, we once again search for documentation by entering help mode to see the fields of this struct.","category":"page"},{"location":"basics.html","page":"Basics","title":"Basics","text":"help?> GrapheneState\nsearch: GrapheneState GrapheneSystem mkGrapheneSystem graphene_neighbors graphene_multiple_neighbors\n\n  GrapheneState(coord::GrapheneCoord, spin::Spin)\n\n  Quantum state of an electron in graphene, denoted by |u, v, L\\rangle\\otimes |\\sigma\\rangle in the drivation.\n\n  The state is given by the GrapheneCoord of the orbital, as well as the electronic spin, which can take values SpinUp and SpinDown.","category":"page"},{"location":"basics.html","page":"Basics","title":"Basics","text":"Following this, we see that the allowed values of the spin field are SpinUp and SpinDown and use them accordingly.","category":"page"},{"location":"basics.html","page":"Basics","title":"Basics","text":"s1 = GrapheneState(c1, SpinUp)\ns2 = GrapheneState(c2, SpinDown)","category":"page"},{"location":"basics.html#Defect-Types","page":"Basics","title":"Defect Types","text":"","category":"section"},{"location":"basics.html","page":"Basics","title":"Basics","text":"There are three kinds of possible defects that can be introduced within the GrapheneQFT framework: ImpurityState, LocalSpin and Hopping. The abstract Defect type encompasses all of these types. As usual, entering help mode and searching for documentation yields details on each defect type. The examples below give an overview of the available Defect types.","category":"page"},{"location":"basics.html","page":"Basics","title":"Basics","text":"# Define coordinates of defect locations\nc1 = GrapheneCoord(0, 0, A)\nc2 = GrapheneCoord(0, 0, B)\n\n# Define an ImpurityState with energy 0.2 eV coupled to c1 with energy 0.1 eV\nimp1 = ImpurityState(0.2, [(0.1, c1)])\n\n# Define a LocalSpin with a z spin component at c2 with coupling strength 0.1 eV\nspin1 = LocalSpin(0.0, 0.0, 0.1, c2)\n\n# Define a Hopping between c1 and c2 with modification of 0.2 eV in hopping energy\nhop1 = Hopping(c1, c2, 0.2)\n\n# Define an onsite energy of 0.05 eV on c1\nener1 = Hopping(c1, c1, 0.05)\nnothing #hide","category":"page"},{"location":"basics.html#Constructing-a-Graphene-System","page":"Basics","title":"Constructing a Graphene System","text":"","category":"section"},{"location":"basics.html","page":"Basics","title":"Basics","text":"To begin calculating relevant quantities, we must first assemble the necessary elements and construct a GrapheneSystem. To do so, we make use of the mkGrapheneSystem, which, as the name suggests, constructs a GrapheneSystem by taking in the chemical potential and temperature of the system and a vector of Defects. The easiest system to construct is, of course, one that is free of defects and is comprised of just pristine graphene.","category":"page"},{"location":"basics.html","page":"Basics","title":"Basics","text":"# Define chemical potential and temperature\nμ = 0.0\nT = 0.0\n\n# Define system\npristine_sys = mkGrapheneSystem(μ, T, Defect[])","category":"page"},{"location":"basics.html","page":"Basics","title":"Basics","text":"Here, we have constructed a pristine system with chemical potential 0.1 eV and temperature at 0.0 K. Note that we have asserted the type of empty vector to be a vector of Defects. As with all other structs, the fields of GrapheneSystem can be accessed in the usual way:","category":"page"},{"location":"basics.html","page":"Basics","title":"Basics","text":"pristine_sys = mkGrapheneSystem(0.1, 0.0, Defect[])#hide\npristine_sys.μ\npristine_sys.T\npristine_sys.Δ\npristine_sys.V\npristine_sys.scattering_states\npristine_sys.imps","category":"page"},{"location":"basics.html","page":"Basics","title":"Basics","text":"Since a pristine system is not a very exciting one, we see that most fields are empty. However, the ability to access these properties will be useful in more complicated systems. When constructing a GrapheneSystem, the parametrization of defects is dependent on the nature of the problem and the types of defects present in the system we wish to investigate.","category":"page"},{"location":"installation.html#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation.html","page":"Installation","title":"Installation","text":"CurrentModule = GrapheneQFT\nDocTestSetup  = quote\n    using GrapheneQFT\nend","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"using GrapheneQFT","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"using GrapheneQFT\nusing Plots","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"This guide is intended to provide the user with basic examples necessary to get started with the package, as well as intermediate examples that extend on the provided set of functions. For users interested in the derivation of the field theoretic calculations, the formalism is covered here. For users purely interested in trying out the package, the list of available functions and their relevance to physical quantities is available here.","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"GrapheneQFT can be installed with the Julia package manager. In the Julia REPL, type ] and run","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"pkg> add GrapheneQFT","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"While still in the package manager, the test suite can be run with test GrapheneQFT to ensure the package is working correctly. After installation, the package is imported in the usual way:","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"using GrapheneQFT","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"We are now ready to explore GrapheneQFT. For the purposes of this guide, it is assumed that the user has a plotting toolset such as Plots.jl installed.","category":"page"},{"location":"index.html#GrapheneQFT.jl","page":"Home","title":"GrapheneQFT.jl","text":"","category":"section"},{"location":"index.html#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"GrapheneQFT.jl is an extendable package written in the Julia programming language that facilitates the field theoretic treatment of impurities on monolayer graphene. It is designed to provide a user-friendly interface to calculate a variety of experimentally relevant QFT quantities in graphene in the presence of external perturbations. We hope that this package makes QFT formalism more approachable and promotes greater research progress by providing users with a readily available computational framework.","category":"page"},{"location":"index.html#Citing","page":"Home","title":"Citing","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"If you find this package useful in your work, please consider citing it:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"@software{rodinalex_2022_6215664,\n  author       = {rodinalex and\n                  harshitra-m},\n  title        = {rodin-physics/GrapheneQFT.jl: v0.4.1},\n  month        = feb,\n  year         = 2022,\n  publisher    = {Zenodo},\n  version      = {v0.4.1},\n  doi          = {10.5281/zenodo.6215664},\n  url          = {https://doi.org/10.5281/zenodo.6215664}\n}","category":"page"}]
}

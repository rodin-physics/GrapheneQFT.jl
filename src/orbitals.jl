include("orbital_data.jl")
orb_2p_radial = LinearInterpolation(rs_DFT, orb_2p_radial_DFT)

nPts = size(coulomb_precompute)[1]
Rmax = 30;
Rs = range(0, Rmax, length = nPts)
τs = range(0, π / 2, length = nPts)
interp_call = LinearInterpolation((Rs, τs), coulomb_precompute)

"""
    Ψ_pz(r::Float64, θ::Float64)

2pz orbital in spherical coordinates.

The radial part is extracted from DFT, while the angular portion is the
spherical harmonic for 2pz (n=2, l=1, m=0) is cos(θ). The wave function does not
depend on ϕ, as expected for a pz orbital.

# Arguments
* `r`: radial distance from the center of the orbital in Bohr radii
* `θ`: polar angle

Note that the function returns 0 for r > 40 since the radial component at
r = 40 is ≈4.5×10⁻¹¹.
"""
@inline function Ψ_pz(r::Float64, θ::Float64)
    if r == 0.0 || r > 40
        return 0.0
    else
        # Note that the DFT values for the radial portion are r R(r)
        # so we divide by an extra factor of r when computing the WF
        return (orb_2p_radial(r) * cos(θ) / r * √(3 / (4 * π)))
    end
end

"""
    coulomb_potential_pz(R::Float64, τ::Float64)

Coulomb potential generated by a 2pz orbital at distance R and polar angle τ
from the center of the orbital.
"""
function coulomb_potential_pz(R::Float64, τ::Float64)
    # The cubature uses spherical coordinates with x[1] = r, x[2] = θ, x[3] = ϕ
    res = hcubature(
        r ->
            Ψ_pz(r[1], r[2]) .^ 2 * r[1]^2 * sin(r[2]) ./ (√(
                r[1]^2 + R^2 -
                2 *
                r[1] *
                R *
                (cos(τ) * cos(r[2]) + cos(r[3]) * sin(τ) * sin(r[2])),
            )),
        [0, 0, 0],
        [40, π, 2 * π],
        reltol = 1e-4,
    )
end

"""
    coulomb_potential_pz_interp(R::Float64, τ::Float64)

Interpolated version of [`coulomb_potential_pz`](@ref).

Since calculating [`coulomb_potential_pz`](@ref) involves computing a 3D
integral, multiple calculations can be costly. Therefore, this function uses
a precomputed grid to approximate [`coulomb_potential_pz`](@ref) for scenarios
when the direct calculation becomes not feasible.
"""
function coulomb_potential_pz_interp(R::Float64, τ::Float64)
    # Because of the pz shape, the potential is symmetric across the xy plane.
    # Hence, if the polar angle τ > π / 2,  we use τ → π - τ
    # (since the precalculation was performed for 0 < τ < π / 2)
    if τ > π / 2
        τ = π - τ
    end
    if R > Rmax
        return 1 / R
    else
        return interp_call(R, τ)
    end
end
